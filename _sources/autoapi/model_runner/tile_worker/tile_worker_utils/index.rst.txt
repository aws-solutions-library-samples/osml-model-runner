model_runner.tile_worker.tile_worker_utils
==========================================

.. py:module:: model_runner.tile_worker.tile_worker_utils


Attributes
----------

.. autoapisummary::

   model_runner.tile_worker.tile_worker_utils.logger


Functions
---------

.. autoapisummary::

   model_runner.tile_worker.tile_worker_utils.setup_tile_workers
   model_runner.tile_worker.tile_worker_utils.process_tiles
   model_runner.tile_worker.tile_worker_utils._create_tile
   model_runner.tile_worker.tile_worker_utils.sizeof_fmt
   model_runner.tile_worker.tile_worker_utils.select_features


Module Contents
---------------

.. py:data:: logger

.. py:function:: setup_tile_workers(region_request: aws.osml.model_runner.api.RegionRequest, sensor_model: Optional[aws.osml.photogrammetry.SensorModel] = None, elevation_model: Optional[aws.osml.photogrammetry.ElevationModel] = None) -> Tuple[queue.Queue, List[model_runner.tile_worker.tile_worker.TileWorker]]

   Sets up a pool of tile-workers to process image tiles from a region request

   :param region_request: RegionRequest = the region request to update.
   :param sensor_model: Optional[SensorModel] = the sensor model for this raster dataset
   :param elevation_model: Optional[ElevationModel] = an elevation model used to fix the elevation of the image coordinate

   :return: Tuple[Queue, List[TileWorker] = a list of tile workers and the queue that manages them


.. py:function:: process_tiles(tiling_strategy: model_runner.tile_worker.tiling_strategy.TilingStrategy, region_request_item: aws.osml.model_runner.database.RegionRequestItem, tile_queue: queue.Queue, tile_workers: List[model_runner.tile_worker.tile_worker.TileWorker], raster_dataset: osgeo.gdal.Dataset, sensor_model: Optional[aws.osml.photogrammetry.SensorModel] = None) -> Tuple[int, int]

   Loads a GDAL dataset into memory and processes it with a pool of tile workers.

   :param tiling_strategy: the approach used to decompose the region into tiles for the ML model
   :param region_request_item: RegionRequestItem = the region request to update.
   :param tile_queue: Queue = keeps the image in the queue for processing
   :param tile_workers: List[TileWorker] = the list of tile workers
   :param raster_dataset: gdal.Dataset = the raster dataset containing the region
   :param sensor_model: Optional[SensorModel] = the sensor model for this raster dataset

   :return: Tuple[int, int, List[ImageRegion]] = number of tiles processed, number of tiles with an error


.. py:function:: _create_tile(gdal_tile_factory, tile_bounds, tmp_image_path, metrics: aws_embedded_metrics.MetricsLogger = None) -> Optional[str]

   Create an encoded tile of the requested image region.

   :param gdal_tile_factory: the factory used to create the tile
   :param tile_bounds: the requested tile boundary
   :param tmp_image_path: the output location of the tile
   :param metrics: the current metrics scope
   :return: the resulting tile path or None if the tile could not be created


.. py:function:: sizeof_fmt(num: float, suffix: str = 'B') -> str

.. py:function:: select_features(feature_distillation_option: str, features: List[geojson.Feature], processing_bounds: aws.osml.model_runner.common.ImageRegion, region_size: str, tile_size: str, tile_overlap: str, tiling_strategy: model_runner.tile_worker.tiling_strategy.TilingStrategy) -> List[geojson.Feature]

   Selects the desired features using the options in the JobItem (NMS, SOFT_NMS, etc.).
   This code applies a feature selector only to the features that came from regions of the image
   that were processed multiple times. First features are grouped based on the region they were
   processed in. Any features found in the overlap area between regions are run through the
   FeatureSelector. If they were not part of an overlap area between regions, they will be grouped
   based on tile boundaries. Any features that fall into the overlap of adjacent tiles are filtered
   by the FeatureSelector. All other features should not be duplicates; they are added to the result
   without additional filtering.

   Computationally, this implements two critical factors that lower the overall processing time for the
   O(N^2) selection algorithms. First, it will filter out the majority of features that couldn't possibly
   have duplicates generated by our tiled image processing; Second, it runs the selection algorithms
   incrementally on much smaller groups of features.

   :param region_size:
   :param feature_distillation_option: str = the options used in selecting features (e.g., NMS/SOFT_NMS, thresholds)
   :param features: List[Feature] = the list of geojson features to process
   :param processing_bounds: the requested area of the image
   :param region_size: str = region size to use for feature dedup
   :param tile_size: str = size of the tiles used during processing
   :param tile_overlap: str = overlap between tiles during processing
   :param tiling_strategy: the tiling strategy to use for feature dedup
   :return: List[Feature] = the list of geojson features after processing


